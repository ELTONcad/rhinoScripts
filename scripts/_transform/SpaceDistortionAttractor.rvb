'Gfield script is an attempt to visualize the units of space-time as they are 
'distorted by a gravity type field. given that each ‘cube’ represents a unit of 
'space-time, greatly enlarged for this purpose, the distortions of each said 
'unit will continue until the geometry can no longer represent a ‘cube’ type 
'space, at which point the ‘cube’ will vanish. at a later time I plan to add 
'additions to the script to uphold a change in geometry from a standard eight 
'point geometric shape to one that can support seven or less points as well as 
'adding mass value which will increase the strength of field generated by the 
'attractor point for each unit of space-time that has collapsed onto the 
'attractor point. the following video is a top view of the change in the 
'quantity of space-time units and how they are distorted over time.
'
'I will, given time, make another ‘perspective view’ video to further represent 
'the three dimensionality of the changes taking place. script is available for 
'download.


Option Explicit
'Script written by shane gregoran
'Script copyrighted by sinQb
'Script version 06 May 2010 18:31:30 updated 21 October 2010

'Call SpaceDistortionAttractor()
Sub SpaceDistortionAttractor()
‘first we create our playground
Dim Area : Area = Rhino.GetInteger(“Area covered”,10)
If IsNull(Area) Then Exit Sub
Dim side : side = Rhino.GetReal(“Distance between points”,0.5)
If IsNull(side) Then Exit Sub
Dim Gforce1 : Gforce1 = Rhino.GetReal(“Strength of the field (higher number yields bigger projection)”, 0.1)
If IsNull(Gforce1) Then Exit Sub
Dim PtNumber : PtNumber = Area^3 – 1
Dim x : x = 0
Dim y : y = 0
Dim z : z = 0
Dim m1 : m1 = 1
Dim m2 : m2 = 1

Dim Sphere, boxID
Dim AttPt, AttPx, AttPy, AttPz
AttPx = (Area*side)/2
AttPy = (Area*side)/2
AttPz = (Area*side)/2
AttPt = Array(AttPx,AttPy,AttPz)
‘Sphere = Rhino.AddSphere (AttPt,2)
‘Rhino.ObjectColor Sphere,RGB(255,0,0)

Dim Box, i, j, k
Dim T : T = -1
Dim A, B, C, D, E, F, G, H
ReDim Box(PtNumber), A(PtNumber), B(PtNumber), C(PtNumber), D(PtNumber), E(PtNumber), F(PtNumber), G(PtNumber), H(PtNumber)

Call Rhino.EnableRedraw(False)
Rhino.Print “please wait… universe is being sucked into a hole”

 

For i = 0 To Area – 1
For j = 0 To Area – 1
For k = 0 To Area – 1
T = T + 1
A(T) = Array((x+i)*side,(y+j)*side,(z+k)*side)
B(T) = Array(((x+i)*side)+side,(y+j)*side,(z+k)*side)
C(T) = Array(((x+i)*side)+side,((y+j)*side)+side,(z+k)*side)
D(T) = Array((x+i)*side,((y+j)*side)+side,(z+k)*side)
E(T) = Array((x+i)*side,(y+j)*side,((z+k)*side)+side)
F(T) = Array(((x+i)*side)+side,(y+j)*side,((z+k)*side)+side)
G(T) = Array(((x+i)*side)+side,((y+j)*side)+side,((z+k)*side)+side)
H(T) = Array((x+i)*side,((y+j)*side)+side,((z+k)*side)+side)
Box(T) = Array(A(T),B(T),C(T),D(T),E(T),F(T),G(T),H(T))
‘boxID = Rhino.AddBox (Box(T))
‘Rhino.ObjectColor boxID, RGB(120,120,120)
Next
Next
Next
‘now we work out the distances
‘F=G*((m1*m2)/r^2)
‘G in this case will be valued at a scale where effects will be obvious
‘m1 and m2 will be added later

Dim GF, dist, n
Dim nAx, nBx,nCx, nDx, nEx, nFx, nGx, nHx
ReDim nAx(PtNumber), nBx(PtNumber), nCx(PtNumber), nDx(PtNumber), nEx(PtNumber), nFx(PtNumber), nGx(PtNumber), nHx(PtNumber)
Dim nAy, nBy, nCy, nDy, nEy, nFy, nGy, nHy
ReDim nAy(PtNumber), nBy(PtNumber), nCy(PtNumber), nDy(PtNumber), nEy(PtNumber), nFy(PtNumber), nGy(PtNumber), nHy(PtNumber)
Dim nAz, nBz, nCz, nDz, nEz, nFz, nGz, nHz
ReDim nAz(PtNumber), nBz(PtNumber), nCz(PtNumber), nDz(PtNumber), nEz(PtNumber), nFz(PtNumber), nGz(PtNumber), nHz(PtNumber)
Dim timeloop
Dim time : time = 1000
Dim cTime, GFchange, GForce, runTime
runTime=0
GForce = Gforce1
GFchange = 0.01

For cTime = 0 To time-1
Gforce = Gforce+GFchange
Rhino.Print “change is ” & (Gforce)

Call Rhino.EnableRedraw(False)

For n = 0 To PtNumber
‘for Ax process
dist = Rhino.Distance(A(n), AttPt)
If dist <> 0 Then
GF = Gforce*((m1*m2)/dist^2)
Else GF = 0
End If
If (A(n)(0)) < AttPx Then
nAx(n) = (A(n)(0)) + GF
End If
If (A(n)(0)) = AttPx Then
nAx(n) = (A(n)(0))
End If
If (A(n)(0)) > AttPx Then
nAx(n) = (A(n)(0)) – GF
End If
If GF > dist Then
nAx(n) = AttPx
End If

‘for Bx process
dist = Rhino.Distance(B(n), AttPt)
If dist <> 0 Then
GF = Gforce*((m1*m2)/dist^2)
Else GF = 0
End If
If (B(n)(0)) < AttPx Then
nBx(n) = (B(n)(0)) + GF
End If
If (B(n)(0)) = AttPx Then
nBx(n) = (B(n)(0))
End If
If (B(n)(0)) > AttPx Then
nBx(n) = (B(n)(0)) – GF
End If
If GF > dist Then
nBx(n) = AttPx
End If

‘for Cx process
dist = Rhino.Distance(C(n), AttPt)
If dist <> 0 Then
GF = Gforce*((m1*m2)/dist^2)
Else GF = 0
End If
If (C(n)(0)) < AttPx Then
nCx(n) = (C(n)(0)) + GF
End If
If (C(n)(0)) = AttPx Then
nCx(n) = (C(n)(0))
End If
If (C(n)(0)) > AttPx Then
nCx(n) = (C(n)(0)) – GF
End If
If GF > dist Then
nCx(n) = AttPx
End If

‘for Dx process
dist = Rhino.Distance(D(n), AttPt)
If dist <> 0 Then
GF = Gforce*((m1*m2)/dist^2)
Else GF = 0
End If
If (D(n)(0)) < AttPx Then
nDx(n) = (D(n)(0)) + GF
End If
If (D(n)(0)) = AttPx Then
nDx(n) = (D(n)(0))
End If
If (D(n)(0)) > AttPx Then
nDx(n) = (D(n)(0)) – GF
End If
If GF > dist Then
nDx(n) = AttPx
End If

‘for Ex process
dist = Rhino.Distance(E(n), AttPt)
If dist <> 0 Then
GF = Gforce*((m1*m2)/dist^2)
Else GF = 0
End If
If (E(n)(0)) < AttPx Then
nEx(n) = (E(n)(0)) + GF
End If
If (E(n)(0)) = AttPx Then
nEx(n) = (E(n)(0))
End If
If (E(n)(0)) > AttPx Then
nEx(n) = (E(n)(0)) – GF
End If
If GF > dist Then
nEx(n) = AttPx
End If

‘for Fx process
dist = Rhino.Distance(F(n), AttPt)
If dist <> 0 Then
GF = Gforce*((m1*m2)/dist^2)
Else GF = 0
End If
If (F(n)(0)) < AttPx Then
nFx(n) = (F(n)(0)) + GF
End If
If (F(n)(0)) = AttPx Then
nFx(n) = (F(n)(0))
End If
If (F(n)(0)) > AttPx Then
nFx(n) = (F(n)(0)) – GF
End If
If GF > dist Then
nFx(n) = AttPx
End If

‘for Gx process
dist = Rhino.Distance(G(n), AttPt)
If dist <> 0 Then
GF = Gforce*((m1*m2)/dist^2)
Else GF = 0
End If
If (G(n)(0)) < AttPx Then
nGx(n) = (G(n)(0)) + GF
End If
If (G(n)(0)) = AttPx Then
nGx(n) = (G(n)(0))
End If
If (G(n)(0)) > AttPx Then
nGx(n) = (G(n)(0)) – GF
End If
If GF > dist Then
nGx(n) = AttPx
End If

‘for Hx process
dist = Rhino.Distance(H(n), AttPt)
If dist <> 0 Then
GF = Gforce*((m1*m2)/dist^2)
Else GF = 0
End If
If (H(n)(0)) < AttPx Then
nHx(n) = (H(n)(0)) + GF
End If
If (H(n)(0)) = AttPx Then
nHx(n) = (H(n)(0))
End If
If (H(n)(0)) > AttPx Then
nHx(n) = (H(n)(0)) – GF
End If
If GF > dist Then
nHx(n) = AttPx
End If

‘for Ay process
dist = Rhino.Distance(A(n), AttPt)
If dist <> 0 Then
GF = Gforce*((m1*m2)/dist^2)
Else GF = 0
End If
If (A(n)(1)) < AttPx Then
nAy(n) = (A(n)(1)) + GF
End If
If (A(n)(1)) = AttPx Then
nAy(n) = (A(n)(1))
End If
If (A(n)(1)) > AttPx Then
nAy(n) = (A(n)(1)) – GF
End If
If GF > dist Then
nAy(n) = AttPy
End If

‘for By process
dist = Rhino.Distance(B(n), AttPt)
If dist <> 0 Then
GF = Gforce*((m1*m2)/dist^2)
Else GF = 0
End If
If (B(n)(1)) < AttPx Then
nBy(n) = (B(n)(1)) + GF
End If
If (B(n)(1)) = AttPx Then
nBy(n) = (B(n)(1))
End If
If (B(n)(1)) > AttPx Then
nBy(n) = (B(n)(1)) – GF
End If
If GF > dist Then
nBy(n) = AttPy
End If

‘for Cy process
dist = Rhino.Distance(C(n), AttPt)
If dist <> 0 Then
GF = Gforce*((m1*m2)/dist^2)
Else GF = 0
End If
If (C(n)(1)) < AttPx Then
nCy(n) = (C(n)(1)) + GF
End If
If (C(n)(1)) = AttPx Then
nCy(n) = (C(n)(1))
End If
If (C(n)(1)) > AttPx Then
nCy(n) = (C(n)(1)) – GF
End If
If GF > dist Then
nCy(n) = AttPy
End If

‘for Dy process
dist = Rhino.Distance(D(n), AttPt)
If dist <> 0 Then
GF = Gforce*((m1*m2)/dist^2)
Else GF = 0
End If
If (D(n)(1)) < AttPx Then
nDy(n) = (D(n)(1)) + GF
End If
If (D(n)(1)) = AttPx Then
nDy(n) = (D(n)(1))
End If
If (D(n)(1)) > AttPx Then
nDy(n) = (D(n)(1)) – GF
End If
If GF > dist Then
nDy(n) = AttPy
End If

‘for Ey process
dist = Rhino.Distance(E(n), AttPt)
If dist <> 0 Then
GF = Gforce*((m1*m2)/dist^2)
Else GF = 0
End If
If (E(n)(1)) < AttPx Then
nEy(n) = (E(n)(1)) + GF
End If
If (E(n)(1)) = AttPx Then
nEy(n) = (E(n)(1))
End If
If (E(n)(1)) > AttPx Then
nEy(n) = (E(n)(1)) – GF
End If
If GF > dist Then
nEy(n) = AttPy
End If

‘for Fy process
dist = Rhino.Distance(F(n), AttPt)
If dist <> 0 Then
GF = Gforce*((m1*m2)/dist^2)
Else GF = 0
End If
If (F(n)(1)) < AttPx Then
nFy(n) = (F(n)(1)) + GF
End If
If (F(n)(1)) = AttPx Then
nFy(n) = (F(n)(1))
End If
If (F(n)(1)) > AttPx Then
nFy(n) = (F(n)(1)) – GF
End If
If GF > dist Then
nFy(n) = AttPy
End If

‘for Gy process
dist = Rhino.Distance(G(n), AttPt)
If dist <> 0 Then
GF = Gforce*((m1*m2)/dist^2)
Else GF = 0
End If
If (G(n)(1)) < AttPx Then
nGy(n) = (G(n)(1)) + GF
End If
If (G(n)(1)) = AttPx Then
nGy(n) = (G(n)(1))
End If
If (G(n)(1)) > AttPx Then
nGy(n) = (G(n)(1)) – GF
End If
If GF > dist Then
nGy(n) = AttPy
End If

‘for Hy process
dist = Rhino.Distance(H(n), AttPt)
If dist <> 0 Then
GF = Gforce*((m1*m2)/dist^2)
Else GF = 0
End If
If (H(n)(1)) < AttPx Then
nHy(n) = (H(n)(1)) + GF
End If
If (H(n)(1)) = AttPx Then
nHy(n) = (H(n)(1))
End If
If (H(n)(1)) > AttPx Then
nHy(n) = (H(n)(1)) – GF
End If
If GF > dist Then
nHy(n) = AttPy
End If

‘for Az process
dist = Rhino.Distance(A(n), AttPt)
If dist <> 0 Then
GF = Gforce*((m1*m2)/dist^2)
Else GF = 0
End If
If (A(n)(2)) < AttPx Then
nAz(n) = (A(n)(2)) + GF
End If
If (A(n)(2)) = AttPx Then
nAz(n) = (A(n)(2))
End If
If (A(n)(2)) > AttPx Then
nAz(n) = (A(n)(2)) – GF
End If
If GF > dist Then
nAz(n) = AttPz
End If

‘for Bz process
dist = Rhino.Distance(B(n), AttPt)
If dist <> 0 Then
GF = Gforce*((m1*m2)/dist^2)
Else GF = 0
End If
If (B(n)(2)) < AttPx Then
nBz(n) = (B(n)(2)) + GF
End If
If (B(n)(2)) = AttPx Then
nBz(n) = (B(n)(2))
End If
If (B(n)(2)) > AttPx Then
nBz(n) = (B(n)(2)) – GF
End If
If GF > dist Then
nBz(n) = AttPz
End If

‘for Cz process
dist = Rhino.Distance(C(n), AttPt)
If dist <> 0 Then
GF = Gforce*((m1*m2)/dist^2)
Else GF = 0
End If
If (C(n)(2)) < AttPx Then
nCz(n) = (C(n)(2)) + GF
End If
If (C(n)(2)) = AttPx Then
nCz(n) = (C(n)(2))
End If
If (C(n)(2)) > AttPx Then
nCz(n) = (C(n)(2)) – GF
End If
If GF > dist Then
nCz(n) = AttPz
End If

‘for Dz process
dist = Rhino.Distance(D(n), AttPt)
If dist <> 0 Then
GF = Gforce*((m1*m2)/dist^2)
Else GF = 0
End If
If (D(n)(2)) < AttPx Then
nDz(n) = (D(n)(2)) + GF
End If
If (D(n)(2)) = AttPx Then
nDz(n) = (D(n)(2))
End If
If (D(n)(2)) > AttPx Then
nDz(n) = (D(n)(2)) – GF
End If
If GF > dist Then
nDz(n) = AttPz
End If

‘for Ez process
dist = Rhino.Distance(E(n), AttPt)
If dist <> 0 Then
GF = Gforce*((m1*m2)/dist^2)
Else GF = 0
End If
If (E(n)(2)) < AttPx Then
nEz(n) = (E(n)(2)) + GF
End If
If (E(n)(2)) = AttPx Then
nEz(n) = (E(n)(2))
End If
If (E(n)(2)) > AttPx Then
nEz(n) = (E(n)(2)) – GF
End If
If GF > dist Then
nEz(n) = AttPz
End If

‘for Fz process
dist = Rhino.Distance(F(n), AttPt)
If dist <> 0 Then
GF = Gforce*((m1*m2)/dist^2)
Else GF = 0
End If
If (F(n)(2)) < AttPx Then
nFz(n) = (F(n)(2)) + GF
End If
If (F(n)(2)) = AttPx Then
nFz(n) = (F(n)(2))
End If
If (F(n)(2)) > AttPx Then
nFz(n) = (F(n)(2)) – GF
End If
If GF > dist Then
nFz(n) = AttPz
End If

‘for Gz process
dist = Rhino.Distance(G(n), AttPt)
If dist <> 0 Then
GF = Gforce*((m1*m2)/dist^2)
Else GF = 0
End If
If (G(n)(2)) < AttPx Then
nGz(n) = (G(n)(2)) + GF
End If
If (G(n)(2)) = AttPx Then
nGz(n) = (G(n)(2))
End If
If (G(n)(2)) > AttPx Then
nGz(n) = (G(n)(2)) – GF
End If
If GF > dist Then
nGz(n) = AttPz
End If

‘for Hz process
dist = Rhino.Distance(H(n), AttPt)
If dist <> 0 Then
GF = Gforce*((m1*m2)/dist^2)
Else GF = 0
End If
If (H(n)(2)) < AttPx Then
nHz(n) = (H(n)(2)) + GF
End If
If (H(n)(2)) = AttPx Then
nHz(n) = (H(n)(2))
End If
If (H(n)(2)) > AttPx Then
nHz(n) = (H(n)(2)) – GF
End If
If GF > dist Then
nHz(n) = AttPz
End If

‘Rhino.AddPoint Array(nAx(n), nAy(n), nAz(n)) – test purposes
Next

Dim nBox, nA, nB, nC, nD, nE, nF, nG, nH, m, IDbox
ReDim nA(PtNumber), nB(PtNumber), nC(PtNumber), nD(PtNumber), nE(PtNumber), nF(PtNumber), nG(PtNumber), nH(PtNumber), nBox(PtNumber), IDbox(PtNumber)
For m = 0 To PtNumber
nA(m) = Array(nAx(m), nAy(m), nAz(m))
nB(m) = Array(nBx(m), nBy(m), nBz(m))
nC(m) = Array(nCx(m), nCy(m), nCz(m))
nD(m) = Array(nDx(m), nDy(m), nDz(m))
nE(m) = Array(nEx(m), nEy(m), nEz(m))
nF(m) = Array(nFx(m), nFy(m), nFz(m))
nG(m) = Array(nGx(m), nGy(m), nGz(m))
nH(m) = Array(nHx(m), nHy(m), nHz(m))
nBox(m) =  Array(nA(m), nB(m), nC(m), nD(m), nE(m), nF(m), nG(m), nH(m))
IDbox(m) = Rhino.AddBox(nBox(m))
Next

Call Rhino.EnableRedraw(True)
‘Rhino.CreatePreviewImage “G1r” & cTime & “.jpg”,,array(1000,800),,True

If runTime = 0 Then
Call Rhino.EnableRedraw(False)
For timeloop = 0 To PtNumber
If IsNull(IDbox(timeloop)) Then
‘Rhino.Print(“space is being eaten by a massive black hole !!!!!”)
Else
Rhino.Sleep 5
Rhino.DeleteObject IDbox(timeloop)
End If
Next
Call Rhino.EnableRedraw(True)
End If
runTime = 0
Next

End Sub